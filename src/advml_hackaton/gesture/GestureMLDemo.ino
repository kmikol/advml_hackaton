/*
  GestureMLDemo.ino
  - Reads APDS-9960 gestures
  - Buffers 4 tokens with a timeout
  - Runs a tiny logistic-regression classifier (weights in model_weights.h)
  - Lights a color for the predicted class, prints details on Serial

  Works with: Arduino_APDS9960
  Board: Arduino Nano 33 BLE Sense (Rev2) or similar
*/

#include <Arduino_APDS9960.h>
#include "model_weights.h"   // generated by Python script

// --- LED helper (RGB if available; else built-in) ---
#ifdef LEDR
  #define HAS_RGB_LED 1
#else
  #define HAS_RGB_LED 0
#endif

void ledOff() {
#if HAS_RGB_LED
  // Active LOW on many NANO BLE boards
  pinMode(LEDR, OUTPUT); pinMode(LEDG, OUTPUT); pinMode(LEDB, OUTPUT);
  digitalWrite(LEDR, HIGH); digitalWrite(LEDG, HIGH); digitalWrite(LEDB, HIGH);
#else
  pinMode(LED_BUILTIN, OUTPUT);
  digitalWrite(LED_BUILTIN, LOW);
#endif
}

void showRGB(bool r, bool g, bool b) {
#if HAS_RGB_LED
  digitalWrite(LEDR, r ? LOW : HIGH);
  digitalWrite(LEDG, g ? LOW : HIGH);
  digitalWrite(LEDB, b ? LOW : HIGH);
#else
  // fallback: blink built-in once
  digitalWrite(LED_BUILTIN, HIGH);
  delay(120);
  digitalWrite(LED_BUILTIN, LOW);
#endif
}

void flashColor(bool r, bool g, bool b, int ms=500) {
  showRGB(r,g,b);
  delay(ms);
  ledOff();
}

// Color map for 4 example classes (edit if you change CLASSES in Python)
void showClassColor(int cls) {
  // PURPLE, CYAN, WHITE, ORANGE
  switch (cls) {
    case 0: showRGB(true, false, true); break;   // purple (R+B)
    case 1: showRGB(false, true, true); break;   // cyan (G+B)
    case 2: showRGB(true, true, true); break;    // white (R+G+B)
    case 3: showRGB(true, true, false); break;   // orange (R+G)
    default: flashColor(false, false, false, 50); break;
  }
}

// --- Gesture buffering ---
const uint32_t GESTURE_GAP_MS = 900;  // end-of-sequence timeout
int seqBuf[ML_SEQ_LEN];
int seqLen = 0;
uint32_t lastGestureMs = 0;

int tokIndexFromGesture(int g) {
  switch (g) {
    case GESTURE_UP:    return 0;
    case GESTURE_DOWN:  return 1;
    case GESTURE_LEFT:  return 2;
    case GESTURE_RIGHT: return 3;
    default: return -1;
  }
}

void resetBuf() {
  seqLen = 0;
  lastGestureMs = 0;
}

// --- ML inference (logits = W*x + b; x is onehot of seq) ---
void encodeOneHot(const int *seq, int L, float *x /*size ML_NUM_FEATS*/) {
  // clear
  for (int i = 0; i < ML_NUM_FEATS; ++i) x[i] = 0.f;
  for (int p = 0; p < L; ++p) {
    int tok = seq[p];
    if (tok >= 0 && tok < ML_VOCAB) {
      x[p*ML_VOCAB + tok] = 1.f;
    }
  }
}

int predictClass(const int *seq) {
  float x[ML_NUM_FEATS];
  encodeOneHot(seq, ML_SEQ_LEN, x);

  int best = 0;
  float bestLogit = -1e9;
  for (int c = 0; c < ML_NUM_CLASSES; ++c) {
    float z = ML_B[c];
    // z += W[c] dot x
    for (int i = 0; i < ML_NUM_FEATS; ++i) {
      z += ML_W[c][i] * x[i];
    }
    if (z > bestLogit) { bestLogit = z; best = c; }
  }
  return best;
}

// --- Setup / Loop ---
void setup() {
  Serial.begin(115200);
  while (!Serial && millis() < 4000) { } // allow time to open
  if (!APDS.begin()) {
    Serial.println("ERROR: APDS begin() failed");
    while (1) { delay(500); }
  }
  ledOff();
  Serial.println("GestureMLDemo ready. Make 4 gestures (UP/DOWN/LEFT/RIGHT). Pause to classify.");
}

void loop() {
  // Read gestures as they arrive
  if (APDS.gestureAvailable()) {
    int g = APDS.readGesture();
    int tok = tokIndexFromGesture(g);
    if (tok >= 0) {
      if (seqLen < ML_SEQ_LEN) {
        seqBuf[seqLen++] = tok;
      }
      lastGestureMs = millis();

      // feedback flash for individual gestures (optional):
      // map tokens to quick color cue:
      if (tok == 0) flashColor(true,false,false,60);         // UP -> red
      else if (tok == 1) flashColor(false,true,false,60);    // DOWN -> green
      else if (tok == 2) flashColor(true,true,false,60);     // LEFT -> yellow
      else if (tok == 3) flashColor(false,false,true,60);    // RIGHT -> blue
    }
  }

  // If we have 4 gestures and a gap, run inference
  if (seqLen == ML_SEQ_LEN && lastGestureMs > 0 && (millis() - lastGestureMs) > GESTURE_GAP_MS) {
    // Predict
    int cls = predictClass(seqBuf);

    // Print sequence and class
    Serial.print("Seq: ");
    for (int i = 0; i < ML_SEQ_LEN; ++i) {
      const char* tokName = "UNK";
      if (seqBuf[i] == 0) tokName = "UP";
      else if (seqBuf[i] == 1) tokName = "DOWN";
      else if (seqBuf[i] == 2) tokName = "LEFT";
      else if (seqBuf[i] == 3) tokName = "RIGHT";
      Serial.print(tokName);
      if (i < ML_SEQ_LEN-1) Serial.print(" ");
    }
    Serial.print("  ->  Class: ");
    if (cls >= 0 && cls < ML_NUM_CLASSES) Serial.print(ML_CLASS_NAMES[cls]);
    else Serial.print(cls);
    Serial.println();

    // Show color
    showClassColor(cls);
    delay(600);
    ledOff();

    // Reset for next sequence
    resetBuf();
  }

  // Safety: if user pauses too long with <4 gestures, clear buffer
  if (seqLen > 0 && lastGestureMs > 0 && (millis() - lastGestureMs) > (GESTURE_GAP_MS*2)) {
    resetBuf();
  }
}
